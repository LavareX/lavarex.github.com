<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>译 Image Resizing Techniques | Lavare</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">译 Image Resizing Techniques</h1><a id="logo" href="/.">Lavare</a><p class="description">Review myself</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">译 Image Resizing Techniques</h1><div class="post-meta">Dec 4, 2017</div><a data-disqus-identifier="2017/12/04/Image-Resizing-Techniques/" href="/2017/12/04/Image-Resizing-Techniques/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><blockquote>
<p>原文：<a href="http://nshipster.com/image-resizing/">Image Resizing Techniques</a><br>作者：<a href="http://nshipster.com/authors/mattt-thompson/">Mattt Thompson</a></p>
</blockquote>
<p>古往今来，iOS 开发者被一个简单的问题所困惑：“如何调整图像大小？”。由于开发者和平台之间相互不信任，导致这个问题令人费解。网页搜索结果中有许许多多的代码示例，都声称是正确的方案，其他的都是错误的。</p>
<p>这真的好尴尬 😂。</p>
<p>本周文章通过对每个在 iOS （和 MacOS，UIImage -&gt; NSImage 进行合适的转换）上的图像大小调整方法进行实验证明提供性能特点，尽力对每个方法提供清晰的解释，而不是简单的用一个方法应用所有场景。</p>
<p><strong>在进一步阅读之前，请注意以下事项:</strong></p>
<p>当在 <code>UIImageView</code> 中设置 <code>UIImage</code> 时，在大多数使用场景中不必手动调整图像大小。可以简单地设置 <code>contentMode</code> 属性为 <code>.scaleAspectFit</code> 确保整张图像显示在 <code>image view</code> 的 <code>frame</code> 中，或者设置为 <code>.scaleAspectFill</code> 让整张图像通过中间裁剪来填充整个 <code>image view</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageView.contentMode = .scaleAspectFit</span><br><span class="line">imageView.image = image</span><br></pre></td></tr></table></figure>
<h2 id="确定缩放大小"><a href="#确定缩放大小" class="headerlink" title="确定缩放大小"></a>确定缩放大小</h2><p>在做任何图像大小调整时，首先必须确定缩放的目标大小。</p>
<h3 id="按系数缩放"><a href="#按系数缩放" class="headerlink" title="按系数缩放"></a>按系数缩放</h3><p>通过常量因子进行图像缩放是最简单的方式。通常来说，这涉及到除以整数以至于减少原来的大小（而不是乘以整数以至于放大原来的大小）。</p>
<p>新的 <code>CGSize</code> 能够通过单独缩放宽度和高度计算得到：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="type">CGSize</span>(width: image.size.width / <span class="number">2</span>, height: image.size.height / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>…或者应用一个 <code>CGAffineTransform</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="type">CGSizeApplyAffineTransform</span>(image.size, <span class="type">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure>
<h3 id="按长宽比缩放"><a href="#按长宽比缩放" class="headerlink" title="按长宽比缩放"></a>按长宽比缩放</h3><p>在不改变原来的长宽比的情况下缩放原来的大小以适合矩形时非常有用。<code>AVFoundation</code> 框架中的 <code>AVMakeRectWithAspectRatioInsideRect</code> 是个有用的函数可以帮助你计算：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"><span class="keyword">let</span> rect = <span class="type">AVMakeRectWithAspectRatioInsideRect</span>(image.size, imageView.bounds)</span><br></pre></td></tr></table></figure>
<h2 id="图像大小调整"><a href="#图像大小调整" class="headerlink" title="图像大小调整"></a>图像大小调整</h2><p>这里有一系列不同的方法去调整图像大小，每个都有不同能力和性能特点。</p>
<h3 id="UIGraphicsBeginImageContextWithOptions-amp-UIImage-drawInRect"><a href="#UIGraphicsBeginImageContextWithOptions-amp-UIImage-drawInRect" class="headerlink" title="UIGraphicsBeginImageContextWithOptions &amp; UIImage -drawInRect:"></a>UIGraphicsBeginImageContextWithOptions &amp; UIImage -drawInRect:</h3><p>图像大小调整的最高级 API 能够在 <code>UIKit</code> 框架中找到。给定 <code>UIImage</code>，通过 <code>UIGraphicsBeginImageContextWithOptions()</code> 和 <code>UIGraphicsGetImageFromCurrentImageContext()</code>，临时图形上下文能够用来渲染成缩放版本的图像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: <span class="keyword">self</span>.<span class="type">URL</span>.absoluteString!)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> size = <span class="type">CGSizeApplyAffineTransform</span>(image.size, <span class="type">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>))</span><br><span class="line"><span class="keyword">let</span> hasAlpha = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> scale: <span class="type">CGFloat</span> = <span class="number">0.0</span> <span class="comment">// Automatically use scale factor of main screen</span></span><br><span class="line"></span><br><span class="line"><span class="type">UIGraphicsBeginImageContextWithOptions</span>(size, !hasAlpha, scale)</span><br><span class="line">image.drawInRect(<span class="type">CGRect</span>(origin: <span class="type">CGPointZero</span>, size: size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scaledImage = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line"><span class="type">UIGraphicsEndImageContext</span>()</span><br></pre></td></tr></table></figure>
<p><code>UIGraphicsBeginImageContextWithOptions()</code> 创建原始绘制的临时渲染上下文。第一个入参 <code>size</code> 是缩放后的图像大小。第二个入参 <code>isOpaque</code> 是用来确定是否需要渲染 alpha 通道。对于不透明（即 alpha 通道）的图像，将其设置为 <code>false</code> 可能会导致粉红色的图像。第三个入参 <code>scale</code> 是显示缩放系数。当设置为 0.0 时，将使用 <code>main screen</code> 的缩放系数，对于 Retina 显示屏，其缩放系数为 2.0 或更高（iPhone 6 Plus 为 3.0）。</p>
<h3 id="CGBitmapContextCreate-amp-CGContextDrawImage"><a href="#CGBitmapContextCreate-amp-CGContextDrawImage" class="headerlink" title="CGBitmapContextCreate &amp; CGContextDrawImage"></a>CGBitmapContextCreate &amp; CGContextDrawImage</h3><p>Core Graphics / Quartz 2D 提供了一套较低级的 API，允许进行更高级的配置。给定 <code>CGImage</code>，通过 <code>CGBitmapContextCreate()</code> 和 <code>CGBitmapContextCreateImage()</code>，临时位图上下文能够用来渲染缩放的图像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cgImage = <span class="type">UIImage</span>(contentsOfFile: <span class="keyword">self</span>.<span class="type">URL</span>.absoluteString!).<span class="type">CGImage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> width = <span class="type">CGImageGetWidth</span>(cgImage) / <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> height = <span class="type">CGImageGetHeight</span>(cgImage) / <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> bitsPerComponent = <span class="type">CGImageGetBitsPerComponent</span>(cgImage)</span><br><span class="line"><span class="keyword">let</span> bytesPerRow = <span class="type">CGImageGetBytesPerRow</span>(cgImage)</span><br><span class="line"><span class="keyword">let</span> colorSpace = <span class="type">CGImageGetColorSpace</span>(cgImage)</span><br><span class="line"><span class="keyword">let</span> bitmapInfo = <span class="type">CGImageGetBitmapInfo</span>(cgImage)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> context = <span class="type">CGBitmapContextCreate</span>(<span class="literal">nil</span>, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo.rawValue)</span><br><span class="line"></span><br><span class="line"><span class="type">CGContextSetInterpolationQuality</span>(context, kCGInterpolationHigh)</span><br><span class="line"></span><br><span class="line"><span class="type">CGContextDrawImage</span>(context, <span class="type">CGRect</span>(origin: <span class="type">CGPointZero</span>, size: <span class="type">CGSize</span>(width: <span class="type">CGFloat</span>(width), height: <span class="type">CGFloat</span>(height))), cgImage)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scaledImage = <span class="type">CGBitmapContextCreateImage</span>(context).flatMap &#123; <span class="type">UIImage</span>(<span class="type">CGImage</span>: $<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure>
<p><code>CGBitmapContextCreate</code> 需要几个参数构建具有所需的尺寸和给定的颜色空间中每个通道的内存量的上下文。在这个例子中，这些值都是从 <code>CGImage</code> 中获取的。接下来，<code>CGContextSetInterpolationQuality</code> 允许上下文以各种保真度水平内插像素。在这种情况下，传递 <code>kCGInterpolationHigh</code> 以获得最佳结果。<code>CGContextDrawImage</code> 允许图像以给定的大小和位置绘制，允许图像在特定的边上被裁剪或者适合一组图像特征，例如面部。最后，<code>CGBitmapContextCreateImage</code> 从上下文中创建 <code>CGImage</code>。</p>
<h3 id="CGImageSourceCreateThumbnailAtIndex"><a href="#CGImageSourceCreateThumbnailAtIndex" class="headerlink" title="CGImageSourceCreateThumbnailAtIndex"></a>CGImageSourceCreateThumbnailAtIndex</h3><p>Image I/O 是一个功能强大但鲜为人知的用于处理图像的框架。独立于 Core Graphics，它能读写很多不同的格式，访问照片的元数据，执行常见的图像处理操作。该框架提供了平台上最快的图像编码器和解码器，具有先进的缓存机制，甚至可以增量加载图像。</p>
<p><code>CGImageSourceCreateThumbnailAtIndex</code> 提供了一个简洁的API，其中包含的选项与在等价的 Core Graphics 调用中找到的选项不同：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ImageIO</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> imageSource = <span class="type">CGImageSourceCreateWithURL</span>(<span class="keyword">self</span>.<span class="type">URL</span>, <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> options: [<span class="type">NSString</span>: <span class="type">NSObject</span>] = [</span><br><span class="line">        kCGImageSourceThumbnailMaxPixelSize: <span class="built_in">max</span>(size.width, size.height) / <span class="number">2.0</span>,</span><br><span class="line">        kCGImageSourceCreateThumbnailFromImageAlways: <span class="literal">true</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> scaledImage = <span class="type">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options).flatMap &#123; <span class="type">UIImage</span>(<span class="type">CGImage</span>: $<span class="number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定一个 <code>CGImageSource</code> 和一组选项，<code>CGImageSourceCreateThumbnailAtIndex</code> 创建了一个缩略图。通过 <code>kCGImageSourceThumbnailMaxPixelSize</code> 完成调整大小。指定最大尺寸除以常数系数可以在保持原始长宽比的同时对图像进行缩放。通过指定 <code>kCGImageSourceCreateThumbnailFromImageIfAbsent</code> 或者 <code>kCGImageSourceCreateThumbnailFromImageAlways</code>，Image I/O 将会自动缓存缩放结果给后续的调用。</p>
<h3 id="Core-Image-的-Lanczos-重采样"><a href="#Core-Image-的-Lanczos-重采样" class="headerlink" title="Core Image 的 Lanczos 重采样"></a>Core Image 的 Lanczos 重采样</h3><p>Core Image 通过 <code>CILanczosScaleTransform</code> 过滤器提供了一个内置的 <a href="https://en.wikipedia.org/wiki/Lanczos_resampling">Lanczos 重采样</a> 功能。尽管可以说是比 UIKit 更高级别的 API，但在 Core Image 中普遍使用键值编码（KVO）使其变得笨拙。</p>
<p>也就是说，至少这种模式是一致的。创建变换过滤器，配置它并渲染成输出图像的过程就像任何其他 Core Image 工作流程一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="type">CIImage</span>(contentsOfURL: <span class="keyword">self</span>.<span class="type">URL</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">filter</span> = <span class="type">CIFilter</span>(name: <span class="string">"CILanczosScaleTransform"</span>)!</span><br><span class="line"><span class="built_in">filter</span>.setValue(image, forKey: <span class="string">"inputImage"</span>)</span><br><span class="line"><span class="built_in">filter</span>.setValue(<span class="number">0.5</span>, forKey: <span class="string">"inputScale"</span>)</span><br><span class="line"><span class="built_in">filter</span>.setValue(<span class="number">1.0</span>, forKey: <span class="string">"inputAspectRatio"</span>)</span><br><span class="line"><span class="keyword">let</span> outputImage = <span class="built_in">filter</span>.valueForKey(<span class="string">"outputImage"</span>) <span class="keyword">as</span>! <span class="type">CIImage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> context = <span class="type">CIContext</span>(options: [kCIContextUseSoftwareRenderer: <span class="literal">false</span>])</span><br><span class="line"><span class="keyword">let</span> scaledImage = <span class="type">UIImage</span>(<span class="type">CGImage</span>: <span class="keyword">self</span>.context.createCGImage(outputImage, fromRect: outputImage.extent()))</span><br></pre></td></tr></table></figure>
<p><code>CILanczosScaleTransform</code> 接收 <code>inputImage</code>，<code>inputScale</code>，和 <code>inputAspectRatio</code>，所有这些都是不言自明的。由于 <code>UIImage(CIImage:)</code> 并不像预期的那样工作，因此需要 <code>CIContext</code> 通过 <code>CGImageRef</code> 中间表示来创建 <code>UIImage</code>。</p>
<p>创建一个 <code>CIContext</code> 是一个昂贵的操作，因此应该总是使用缓存的上下文来重复调整大小。<code>CIContext</code> 可以使用 GPU 或者 CPU（慢得多）来创建 <code>CIContext</code> 进行渲染 - 使用选项字典中的 <code>kCIContextUseSoftwareRenderer</code> 键来指定哪一个。</p>
<h3 id="Accelerate-中的-vImage"><a href="#Accelerate-中的-vImage" class="headerlink" title="Accelerate 中的 vImage"></a>Accelerate 中的 vImage</h3><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Accelerate/Reference/AccelerateFWRef/index.html#//apple_ref/doc/uid/TP40009465">Accelerate 框架</a> 包含一套 <code>vImage</code> 图像处理功能，并具有一组缩放图像缓冲区的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/vImage_geometric/index.html#//apple_ref/doc/uid/TP40005490-CH212-145717">功能</a>。这些较低级别的 API 保证以较低的功耗实现高性能，但是要以自己管理缓冲区为代价。以下是 <a href="https://gist.github.com/Nyx0uf/217d97f81f4889f4445a">GitHub 上 Nyx0uf 提供</a>的 Swift 版本的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cgImage = <span class="type">UIImage</span>(contentsOfFile: <span class="keyword">self</span>.<span class="type">URL</span>.absoluteString!).<span class="type">CGImage</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create a source buffer</span></span><br><span class="line"><span class="keyword">var</span> format = vImage_CGImageFormat(bitsPerComponent: <span class="number">8</span>, bitsPerPixel: <span class="number">32</span>, colorSpace: <span class="literal">nil</span>,</span><br><span class="line">    bitmapInfo: <span class="type">CGBitmapInfo</span>(rawValue: <span class="type">CGImageAlphaInfo</span>.<span class="type">First</span>.rawValue),</span><br><span class="line">    version: <span class="number">0</span>, decode: <span class="literal">nil</span>, renderingIntent: <span class="type">CGColorRenderingIntent</span>.<span class="type">RenderingIntentDefault</span>)</span><br><span class="line"><span class="keyword">var</span> sourceBuffer = vImage_Buffer()</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">    sourceBuffer.data.dealloc(<span class="type">Int</span>(sourceBuffer.height) * <span class="type">Int</span>(sourceBuffer.height) * <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> error = vImageBuffer_InitWithCGImage(&amp;sourceBuffer, &amp;format, <span class="literal">nil</span>, cgImage, <span class="built_in">numericCast</span>(kvImageNoFlags))</span><br><span class="line"><span class="keyword">guard</span> error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a destination buffer</span></span><br><span class="line"><span class="keyword">let</span> scale = <span class="type">UIScreen</span>.mainScreen().scale</span><br><span class="line"><span class="keyword">let</span> destWidth = <span class="type">Int</span>(image.size.width * <span class="number">0.5</span> * scale)</span><br><span class="line"><span class="keyword">let</span> destHeight = <span class="type">Int</span>(image.size.height * <span class="number">0.5</span> * scale)</span><br><span class="line"><span class="keyword">let</span> bytesPerPixel = <span class="type">CGImageGetBitsPerPixel</span>(image.<span class="type">CGImage</span>) / <span class="number">8</span></span><br><span class="line"><span class="keyword">let</span> destBytesPerRow = destWidth * bytesPerPixel</span><br><span class="line"><span class="keyword">let</span> destData = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">UInt8</span>&gt;.alloc(destHeight * destBytesPerRow)</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">    destData.dealloc(destHeight * destBytesPerRow)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> destBuffer = vImage_Buffer(data: destData, height: vImagePixelCount(destHeight), width: vImagePixelCount(destWidth), rowBytes: destBytesPerRow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// scale the image</span></span><br><span class="line">error = vImageScale_ARGB8888(&amp;sourceBuffer, &amp;destBuffer, <span class="literal">nil</span>, <span class="built_in">numericCast</span>(kvImageHighQualityResampling))</span><br><span class="line"><span class="keyword">guard</span> error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a CGImage from vImage_Buffer</span></span><br><span class="line"><span class="keyword">let</span> destCGImage = vImageCreateCGImageFromBuffer(&amp;destBuffer, &amp;format, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="built_in">numericCast</span>(kvImageNoFlags), &amp;error)?.takeRetainedValue()</span><br><span class="line"><span class="keyword">guard</span> error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a UIImage</span></span><br><span class="line"><span class="keyword">let</span> scaledImage = destCGImage.flatMap &#123; <span class="type">UIImage</span>(<span class="type">CGImage</span>: $<span class="number">0</span>, scale: <span class="number">0.0</span>, orientation: image.imageOrientation) &#125;</span><br></pre></td></tr></table></figure>
<p>这里使用的 Accelerate API 明显比其他调整大小的方法在更低的层次上运行。要使用这个方法，<br>首先通过 <code>vImageBuffer_InitWithCGImage()</code> 用 <code>vImage_CGImageFormat</code> 从你的 CGImage 中创建源缓存区。目标缓冲区以所需的图像分辨率进行分配，然后 <code>vImageScale_ARGB8888</code> 完成调整图像大小的实际工作。当对大于应用程序内存限制的图像进行操作时需要管理自己的缓冲区，这是留给读者的一个练习。</p>
<h2 id="性能基准"><a href="#性能基准" class="headerlink" title="性能基准"></a>性能基准</h2><p>那么这些各种方法如何相互叠加呢？</p>
<p>以下是通过<a href="https://github.com/natecook1000/Image-Resizing">此项目</a>在运行 iOS 8.4 的 iPhone 6 上完成的一组<a href="http://nshipster.com/benchmarking/">性能基准</a>的结果：</p>
<h3 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h3><p>加载，缩放和显示来自<a href="http://visibleearth.nasa.gov/view.php?id=78314">美国宇航局 Visible Earth</a> 的大尺寸高分辨率（12000 ⨉ 12000 px 20 MB JPEG）源图像在 1/10 的大小：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Time (sec)</th>
<th style="text-align:center">σ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UIKit</td>
<td style="text-align:center">0.612</td>
<td style="text-align:center">14%</td>
</tr>
<tr>
<td style="text-align:center">Core Graphics<sup>1</sup></td>
<td style="text-align:center">0.266</td>
<td style="text-align:center">3%</td>
</tr>
<tr>
<td style="text-align:center">Image I/O</td>
<td style="text-align:center">0.255</td>
<td style="text-align:center">2%</td>
</tr>
<tr>
<td style="text-align:center">Core Image<sup>2</sup></td>
<td style="text-align:center">3.703</td>
<td style="text-align:center">33%</td>
</tr>
<tr>
<td style="text-align:center">vImage<sup>3</sup></td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
</tr>
</tbody>
</table>
<h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><p>加载、缩放和显示一个相当大的（1024 ⨉ 1024 px 1MB PNG）渲染的 <a href="http://postgresapp.com/">Postgres.app</a> 图标在 1/10 的大小：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Time (sec)</th>
<th style="text-align:center">σ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UIKit</td>
<td style="text-align:center">0.044</td>
<td style="text-align:center">30%</td>
</tr>
<tr>
<td style="text-align:center">Core Graphics<sup>4</sup></td>
<td style="text-align:center">0.036</td>
<td style="text-align:center">10%</td>
</tr>
<tr>
<td style="text-align:center">Image I/O</td>
<td style="text-align:center">0.038</td>
<td style="text-align:center">11%</td>
</tr>
<tr>
<td style="text-align:center">Core Image<sup>5</sup></td>
<td style="text-align:center">0.053</td>
<td style="text-align:center">68%</td>
</tr>
<tr>
<td style="text-align:center">vImage</td>
<td style="text-align:center">0.050</td>
<td style="text-align:center">25%</td>
</tr>
</tbody>
</table>
<p><sup>1</sup>, <sup>4</sup> 结果在不同的 <code>CGInterpolationQuality</code> 值上是一致的，在性能基准上差异可以忽略不计。</p>
<p><sup>3</sup> 美国宇航局 Visible Earth 图像的大小大于设备一次能够处理的大小。</p>
<p><sup>2</sup>, <sup>5</sup> 在 <code>CIContext</code> 创建时所传的选项中设置 <code>kCIContextUseSoftwareRenderer</code> 为 true 会产生比基础结果慢一个数量级的结果。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li><strong>UIKit</strong>，<strong>Core Graphics</strong>，和 <strong>Image I/O</strong> 在大多数图像上都可以很好地进行缩放操作。</li>
<li><strong>Core Image</strong> 在图像缩放操作方面表现优异。实际上，<a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/Conceptual/CoreImaging/ci_performance/ci_performance.html#//apple_ref/doc/uid/TP30001185-CH10-SW1">Core Image 编程指南的性能最佳实践章节</a>特别推荐使用 Core Graphics 或者 Image I/O 函数预先裁剪或者降低采样图像。</li>
<li>对于一般的没有任何额外功能的图像缩放，<strong>UIGraphicsBeginImageContextWithOptions</strong> 可能是最好的选择。</li>
<li>如果需要考虑图像质量，考虑使用 <strong>CGBitmapContextCreate</strong> 结合 <strong>CGContextSetInterpolationQuality</strong>。</li>
<li>当缩放图像的目的是显示缩略图时，<strong>CGImageSourceCreateThumbnailAtIndex</strong> 为渲染和缓存提供了一个引人注目的解决方案。</li>
<li>除非你已经在使用 <strong>vImage</strong>，否则使用低级 Accelerate 框架进行大小调整的额外工作并不值得。</li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yangcaimu.github.io/2017/12/04/Image-Resizing-Techniques/" data-id="cjaqz8rmw000bmtuzrb3xihfn" class="article-share-link">分享到</a><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/翻译/">翻译</a></div><div class="post-nav"><a href="/2017/10/22/读-SDWebImage-源码小记/" class="next">读 SDWebImage 源码小记</a></div><div id="disqus_thread"><script>var disqus_shortname = 'yangcaimu-blog';
var disqus_identifier = '2017/12/04/Image-Resizing-Techniques/';
var disqus_title = '译 Image Resizing Techniques';
var disqus_url = 'http://yangcaimu.github.io/2017/12/04/Image-Resizing-Techniques/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//yangcaimu-blog.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yangcaimu.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/Skills/" style="font-size: 15px;">Skills</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/Alfred/" style="font-size: 15px;">Alfred</a> <a href="/tags/Workflow/" style="font-size: 15px;">Workflow</a> <a href="/tags/Xcode/" style="font-size: 15px;">Xcode</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Constraint/" style="font-size: 15px;">Constraint</a> <a href="/tags/写作/" style="font-size: 15px;">写作</a> <a href="/tags/SDWebImage/" style="font-size: 15px;">SDWebImage</a> <a href="/tags/Octopress/" style="font-size: 15px;">Octopress</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/04/Image-Resizing-Techniques/">译 Image Resizing Techniques</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/22/读-SDWebImage-源码小记/">读 SDWebImage 源码小记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/05/添加约束的恰当时机/">添加约束的恰当时机</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/12/写作本身的一些参考资料/">写作本身的一些参考资料</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/09/Alfred-workflow-快速打开-Xcode-工程/">Alfred workflow: 快速打开 Xcode 工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/05/25/windowshiyongjiqiao/">Windows 使用技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/05/24/macshiyongjiqiao/">Mac 使用技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/04/25/dajianblogzhilu/">搭建 Blog 之旅</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Lavare.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-51815558-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?f2332cdab78cfdaaf85ad19f83bb65b1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>